using System;
using System.Collections.Generic;
using System.IO;
using NLog;
using pdfforge.PDFCreator.Core.Actions;
using pdfforge.PDFCreator.Core.Settings;
using pdfforge.PDFCreator.Core.Settings.Enums;
using pdfforge.PDFCreator.Utilities;
using pdfforge.PDFCreator.Utilities.Tokens;
using pdfforge.PDFProcessing;

namespace pdfforge.PDFCreator.Core.Jobs
{
    /// <summary>
    ///     AbstractJob implements a few methods of the Job interface that can be shared among the Job types
    /// </summary>
    public abstract class AbstractJob : IJob
    {
        protected readonly Logger Logger = LogManager.GetCurrentClassLogger();
        private bool _cleanedUp;

        /// <summary>
        ///     Actions that will be executed after converting the job
        /// </summary>
        public IList<IAction> JobActions { get; protected set; }

        /// <summary>
        ///     An Error message with an internal state of what went wrong. May be untranslated.
        /// </summary>
        public string ErrorMessage { get; protected set; }

        /// <summary>
        ///     The type of the Error or JobError.None, if no error happened
        /// </summary>
        public JobError ErrorType { get; protected set; }

        /// <summary>
        ///     OnActionAdded is fired when a new action was added to the Job
        /// </summary>
        public event EventHandler<ActionAddedEventArgs> OnActionAdded;

        /// <summary>
        ///     JobInfo that defines the current Job (soure files, Metadata etc)
        /// </summary>
        public IJobInfo JobInfo { get; protected set; }

        /// <summary>
        ///     The Profile settings that are used in the job
        /// </summary>
        public ConversionProfile Profile { get; set; }

        public TokenReplacer TokenReplacer { get; set; }

        /// <summary>
        ///     Holds passwords for encryption etc.
        /// </summary>
        public JobPasswords Passwords { get; set; }

        /// <summary>
        ///     Holds translations required during the job
        /// </summary>
        public JobTranslations JobTranslations { get; set; }

        /// <summary>
        ///     Automatically clean up input files after the job has been processed
        /// </summary>
        public bool AutoCleanUp { get; set; }

        /// <summary>
        ///     The Output files that have been generated by this job
        /// </summary>
        public IList<string> OutputFiles { get; set; }

        /// <summary>
        ///     The template for the output files. This may contain a wildcard to create multiple files, i.e. a file per page. The
        ///     template is used to construct the final output filename.
        /// </summary>
        public string OutputFilenameTemplate { get; set; }

        /// <summary>
        ///     The folder in which the job can store temporary data
        /// </summary>
        public string JobTempFolder { get; set; }

        /// <summary>
        ///     The folder in which the job produces the output files
        /// </summary>
        public string JobTempOutputFolder { get; set; }

        /// <summary>
        ///     Temporary filename of the output file
        /// </summary>
        public string JobTempFileName
        {
            get { return "output"; }
        }

        /// <summary>
        ///     Flag to skip the SaveFileDialog (Therefore an OutputFilename must be set)
        /// </summary>
        public bool SkipSaveFileDialog { get; set; }

        /// <summary>
        ///     If true, the job has completed execution
        /// </summary>
        public bool Completed { get; set; }

        /// <summary>
        ///     If true, the job was successful
        /// </summary>
        public bool Success { get; set; }

        private int _numberOfPagesFromSourceFiles = -1;
        /// <summary>
        ///     The number of pages in the print job
        /// </summary>
        public int PageCount
        {
            get
            {
                int numberOfPages = 0;
                if (_numberOfPagesFromSourceFiles < 0) 
                    _numberOfPagesFromSourceFiles = CountPagesInSourceFiles();

                numberOfPages += _numberOfPagesFromSourceFiles;
                numberOfPages += GetNumberOfCoverPages();
                numberOfPages += GetNumberOfAttachmentPages();

                return numberOfPages;
            }
        }

        /// <summary>
        /// Determine number of pages in cover file 
        /// </summary>
        /// <returns>Number of pages in cover file</returns>
        private int GetNumberOfCoverPages()
        {
            var count = 0;
            if (Profile.CoverPage.Enabled)
            {
                try
                {
                    count += PDFProcessor.GetNumberOfPages(Profile.CoverPage.File);
                }
                catch
                {
                    Logger.Warn("Problem detecting page number of cover page file \"" + Profile.CoverPage.File + "\"");
                    count = 1;
                }
            }
            return count;
        }

        /// <summary>
        /// Determine number of pages in attachment file 
        /// </summary>
        /// <returns>Number of pages in attachment file</returns>
        private int GetNumberOfAttachmentPages()
        {
            var count = 0;
            if (Profile.AttachmentPage.Enabled)
            {
                try
                {
                    count += PDFProcessor.GetNumberOfPages(Profile.AttachmentPage.File);
                }
                catch
                {
                    Logger.Warn("Problem detecting page number of attachment page file \"" + Profile.AttachmentPage.File + "\"");
                    count = 1;
                }
            }
            return count;
        }

        /// <summary>
        ///     Clean up all temporary files that have been generated during the Job
        /// </summary>
        public void CleanUp()
        {
            Logger.Debug("Cleaning up after the job");

            if (_cleanedUp)
            {
                Logger.Debug("Job was cleaned up already");
                return;
            }

            // Delete temporary output
            if (!String.IsNullOrEmpty(JobTempFolder) && Path.IsPathRooted(JobTempFolder) &&
                Directory.Exists(JobTempFolder))
            {
                try
                {
                    Directory.Delete(JobTempFolder, true);
                }
                catch (IOException ex)
                {
                    Logger.Warn("Error while deleting temporary folder: " + ex.Message);
                }
            }

            // Delete source files
            foreach (var file in JobInfo.SourceFiles)
            {
                try
                {
                    File.Delete(file.Filename);
                    DeleteFolderIfEmptyAndNotSpool(Path.GetDirectoryName(file.Filename));
                }
                catch (IOException ex)
                {
                    Logger.Warn("Error while deleting source file: " + ex.Message);
                }
            }

            // Delete inf file
            try
            {
                File.Delete(JobInfo.InfFile);
                DeleteFolderIfEmptyAndNotSpool(Path.GetDirectoryName(JobInfo.InfFile));
            }
            catch (IOException ex)
            {
                Logger.Warn("Error while deleting job file: " + ex.Message);
            }

            _cleanedUp = true;
        }

        private void DeleteFolderIfEmptyAndNotSpool(string directoryPath)
        {
            var directoryInfo = new DirectoryInfo(directoryPath);
            var name = directoryInfo.Name;

            // ensure the spool folder is never deleted, because doing so can lead to problems
            if (string.Equals("Spool", name, StringComparison.InvariantCultureIgnoreCase))
                return;

            DeleteFolderIfEmpty(directoryPath);
        }

        /// <summary>
        ///     Compose the output filename based on settings, output format etc.
        /// </summary>
        /// <returns>composed output filename</returns>
        public string ComposeOutputFilename()
        {
            var outputFilename = FileUtil.MakeValidFileName(TokenReplacer.ReplaceTokens(Profile.FileNameTemplate));

            switch (Profile.OutputFormat)
            {
                case OutputFormat.Pdf:
                    outputFilename += ".pdf";
                    break;
                case OutputFormat.Jpeg:
                    outputFilename += ".jpg";
                    break;
                case OutputFormat.Png:
                    outputFilename += ".png";
                    break;
                case OutputFormat.Tif:
                    outputFilename += ".tif";
                    break;
                default:
                    Logger.Warn("Can't find a supported Output format! File format is defaulted to .pdf");
                    outputFilename += ".pdf";
                    break;
            }

            if (outputFilename.Length > FileUtil.MAX_PATH)
            {
                outputFilename = FileUtil.EllipsisForPath(outputFilename, 250);
            }

            return outputFilename;
        }

        /// <summary>
        ///     Runs the job and all actions
        /// </summary>
        public void RunJob()
        {
            Logger.Trace("Starting job");

            var calledJobCompleted = false;

            try
            {
                var success = RunJobWork();

                if (!success)
                {
                    Logger.Error("Executing Ghostscript failed");
                    CallJobCompleted(false, JobError.Ghostscript);
                    calledJobCompleted = true;
                    return;
                }

                var outputFilenames = new List<string>();
                Logger.Trace("Created {0} output files", OutputFiles.Count);

                if (OutputFiles.Count == 0)
                {
                    Logger.Error("No output files were created for unknown reason");
                    CallJobCompleted(false, JobError.Unknown);
                    calledJobCompleted = true;
                    return;
                }

                foreach (var fileWithPath in OutputFiles)
                {
                    var f = Path.GetFileName(fileWithPath);
                    outputFilenames.Add(f);

                    Logger.Trace("Output file: {0}", f);
                }

                TokenReplacer.AddToken(new ListToken("OutputFilenames", outputFilenames));
                TokenReplacer.AddToken(new StringToken("OutputFilePath", Path.GetFullPath(OutputFiles[0])));

                Logger.Trace("Starting Actions");

                foreach (var action in JobActions)
                {
                    Logger.Trace("Calling Action {0}", action.GetType().Name);
                    if (OnEvaluateActionResult != null)
                    {
                        if (!OnEvaluateActionResult(action.ProcessJob(this)))
                            break;
                    }
                    else
                    {
                        action.ProcessJob(this);
                        Logger.Trace("Action {0} completed", action.GetType().Name);
                    }
                }

                if (AutoCleanUp)
                {
                    Logger.Trace("Automatically cleaning up the job");
                    CleanUp();
                }

                Logger.Trace("Job finished");
            }
            finally
            {
                if (!calledJobCompleted)
                {
                    Logger.Trace("Calling job completed event");
                    CallJobCompleted();
                }
            }
        }

        /*
        /// <summary>
        ///     Creates a BackgroundWorker to run this Job asynchronously.
        /// </summary>
        /// <param name="startRunning">If true, the Job will start upon creation</param>
        /// <returns>The BackGround worker</returns>
        public BackgroundWorker RunJobAsync(bool startRunning)
        {
            JobWorker = new BackgroundWorker();
            JobWorker.DoWork += RunJob;
            JobWorker.WorkerReportsProgress = true;
            JobWorker.WorkerSupportsCancellation = true;

            // call virtual method to allow inherited classes to add things to the worker
            EnhanceJobWorker();

            if (startRunning)
                JobWorker.RunWorkerAsync();

            return JobWorker;
        }*/

        public void AddAction(IAction action)
        {
            var e = new ActionAddedEventArgs(this, action);
            if (OnActionAdded != null)
            {
                OnActionAdded(this, e);
            }

            if (!e.SkipAction)
                JobActions.Add(action);
        }

        /// <summary>
        ///     Applies Metadata to the current job
        /// </summary>
        public abstract void ApplyMetadata();

        /// <summary>
        ///     Initis and applies Metadata to the current job
        /// </summary>
        public abstract void InitMetadata();

        public event JobEvent.EvaluateActionResult OnEvaluateActionResult;
        public abstract event EventHandler OnRecommendPdfArchitect;
        public abstract event EventHandler<QueryPasswordEventArgs> OnRetypeSmtpPassword;
        public event EventHandler<JobCompletedEventArgs> OnJobCompleted;
        public event EventHandler<JobProgressChangedEventArgs> OnJobProgressChanged;

        private void CallJobCompleted()
        {
            CallJobCompleted(true, JobError.None);
        }

        private void CallJobCompleted(bool success, JobError errorType)
        {
            Completed = true;
            Success = success;
            ErrorType = errorType;

            if (OnJobCompleted != null)
            {
                OnJobCompleted(this, new JobCompletedEventArgs(this));
            }
        }

        protected abstract bool RunJobWork();
        protected abstract int CountPagesInSourceFiles();

        private void DeleteFolderIfEmpty(string folder)
        {
            if (FileUtil.DirectoryIsEmpty(folder))
            {
                Directory.Delete(folder);
            }
        }

        protected void ReportProgress(int percentProgress)
        {
            ReportProgress(percentProgress, null);
        }

        protected void ReportProgress(int percentProgress, object userState)
        {
            if (OnJobProgressChanged != null)
                OnJobProgressChanged(this, new JobProgressChangedEventArgs(this, percentProgress));
        }
    }
}